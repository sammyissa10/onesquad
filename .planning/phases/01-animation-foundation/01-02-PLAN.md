---
phase: 01-animation-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/providers/SmoothScrollProvider.tsx
  - src/lib/hooks/useReducedMotion.ts
  - src/components/ui/ScrollToTop.tsx
autonomous: false

must_haves:
  truths:
    - "Users who prefer reduced motion get instant/no-animation experience — Lenis smooth scroll is disabled, GSAP animations are suppressed"
    - "ScrollTrigger instances created inside useGSAP are automatically cleaned up on route changes — no ghost triggers persist"
    - "After navigating between 5+ pages, no ScrollTrigger memory leak (trigger count returns to baseline)"
    - "Dev can verify smooth scroll, reduced motion, and cleanup behavior by running the app"
  artifacts:
    - path: "src/lib/hooks/useReducedMotion.ts"
      provides: "Reactive hook that returns whether user prefers reduced motion"
      exports: ["useReducedMotion"]
  key_links:
    - from: "src/lib/providers/SmoothScrollProvider.tsx"
      to: "src/lib/hooks/useReducedMotion.ts"
      via: "useReducedMotion() conditionally disables Lenis smooth scroll"
      pattern: "useReducedMotion"
    - from: "src/lib/providers/SmoothScrollProvider.tsx"
      to: "src/lib/gsap.ts"
      via: "ScrollTrigger.refresh() on route change for cleanup support"
      pattern: "ScrollTrigger\\.refresh"
---

<objective>
Add accessibility support (prefers-reduced-motion) and verify ScrollTrigger cleanup works correctly on route changes.

Purpose: Ensure the animation foundation respects accessibility preferences and doesn't leak memory — both are non-negotiable for production quality. This completes the ANIM-05 and ANIM-06 requirements.

Output: Reduced motion hook, updated SmoothScrollProvider with accessibility awareness, verified cleanup behavior.
</objective>

<execution_context>
@C:/Users/sammy/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/sammy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-animation-foundation/01-RESEARCH.md
@.planning/phases/01-animation-foundation/01-01-SUMMARY.md
@src/lib/gsap.ts
@src/lib/providers/SmoothScrollProvider.tsx
@src/app/layout.tsx
@src/app/globals.css
@src/components/ui/ScrollToTop.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reduced motion hook and integrate into SmoothScrollProvider</name>
  <files>src/lib/hooks/useReducedMotion.ts, src/lib/providers/SmoothScrollProvider.tsx</files>
  <action>
1. Create `src/lib/hooks/useReducedMotion.ts`:
   - "use client" component hook
   - Use `useState` + `useEffect` to listen to `window.matchMedia('(prefers-reduced-motion: reduce)')`
   - Return `prefersReducedMotion: boolean`
   - Listen to the `change` event on the MediaQueryList so the hook updates reactively if the user toggles the setting in OS preferences while the page is open
   - Default to `false` during SSR (safe default — animations enabled until we know otherwise)
   - Clean up event listener on unmount

2. Update `src/lib/providers/SmoothScrollProvider.tsx`:
   - Import `useReducedMotion` from `@/lib/hooks/useReducedMotion`
   - When `prefersReducedMotion` is true:
     - Pass `autoRaf={false}` still, but call `lenisRef.current?.lenis?.stop()` to halt Lenis entirely
     - Do NOT render ReactLenis with `smoothWheel`/`smoothTouch` — instead pass `smoothWheel: false, smoothTouch: false` to effectively disable smooth scrolling while keeping Lenis mounted (avoids conditional render issues)
   - When `prefersReducedMotion` is false:
     - Normal behavior (smooth scroll active)
   - Use a `useEffect` keyed on `prefersReducedMotion` to call `lenis.start()` or `lenis.stop()` reactively
   - This approach means: reduced motion users get native browser scrolling (instant, no momentum), and when GSAP animations are added in later phases, `gsap.matchMedia('(prefers-reduced-motion: reduce)')` blocks will provide instant/no-animation fallbacks

3. Update `src/components/ui/ScrollToTop.tsx`:
   - The `scrollToTop` function currently uses `window.scrollTo({ top: 0, behavior: "smooth" })`. With Lenis active, this should work because Lenis intercepts native scroll calls. However, when Lenis is stopped (reduced motion), native scroll takes over — which is correct behavior.
   - No changes needed IF ScrollToTop works correctly with Lenis in plan 01-01. If plan 01-01's SUMMARY indicates ScrollToTop doesn't work with Lenis, update it here to use `lenis.scrollTo(0)` by accessing the lenis instance via a React context or ref.
   - READ the 01-01-SUMMARY.md first before deciding whether to modify this file.

IMPORTANT: This task does NOT add any visible animations. It only ensures the infrastructure layer respects accessibility. Visible animation work happens in Phase 8.

DISCRETION — Reduced motion strategy: When prefers-reduced-motion is active, we DISABLE smooth scroll (Lenis stops) rather than just simplifying it. The user asked for accessibility compliance, and the cleanest approach is: reduced motion = native scroll + no GSAP animations. This gives the most predictable experience for users who need it.
  </action>
  <verify>
- `npx tsc --noEmit` — no TypeScript errors
- `npm run build` — builds successfully
- In browser: Enable "Prefer reduced motion" in OS accessibility settings (or Chrome DevTools > Rendering > prefers-reduced-motion: reduce)
  - With reduced motion ON: scroll should be native (instant, no momentum, no smooth interpolation)
  - With reduced motion OFF: scroll should be Lenis smooth scroll (fluid, momentum-based)
- Toggle reduced motion while page is open — behavior should switch reactively without page reload
  </verify>
  <done>useReducedMotion hook exists and reactively tracks the prefers-reduced-motion media query. SmoothScrollProvider disables Lenis when reduced motion is preferred. Toggling the setting mid-session works without reload.</done>
</task>

<task type="auto">
  <name>Task 2: Verify ScrollTrigger cleanup on route changes</name>
  <files>src/lib/providers/SmoothScrollProvider.tsx</files>
  <action>
1. Ensure SmoothScrollProvider's route-change effect (from plan 01-01) includes a `ScrollTrigger.killAll()` BEFORE the `ScrollTrigger.refresh()` call:
   - On route change (pathname changes):
     a. Kill all existing ScrollTriggers: `ScrollTrigger.getAll().forEach(st => st.kill())`
     b. Scroll to top instantly: `lenis.scrollTo(0, { immediate: true })`
     c. After a short delay (requestAnimationFrame or 100ms setTimeout): `ScrollTrigger.refresh()`
   - This ensures no "ghost" triggers persist from the previous page

   NOTE: In Phase 1, there are no ScrollTrigger instances yet (no scroll animations created). This is a PREVENTIVE measure. The cleanup pattern must be in place NOW so that when Phase 8 adds scroll animations, they clean up automatically. The useGSAP hook from @gsap/react handles per-component cleanup, but the route-level killAll is a safety net for any edge cases.

2. Add a development-only debug helper:
   - In `SmoothScrollProvider`, add a `useEffect` that runs only in development (`process.env.NODE_ENV === 'development'`):
     ```
     console.debug(`[ScrollTrigger] Active instances: ${ScrollTrigger.getAll().length}`)
     ```
   - Log this on every route change so developers can verify during Phase 8 that trigger count returns to 0 after navigation
   - This is a temporary dev aid — can be removed in production or left as debug-level logging

3. Verify the overall cleanup chain:
   - Component unmount → useGSAP auto-reverts all GSAP instances in that component's scope
   - Route change → SmoothScrollProvider kills remaining ScrollTriggers + refreshes
   - This double-layer cleanup prevents the memory leak described in Research Pitfall 2
  </action>
  <verify>
- `npm run build` — builds successfully
- `npm run dev` — navigate between 5+ pages rapidly using navigation links
- Open browser DevTools console — no GSAP/ScrollTrigger errors, dev debug log shows trigger count
- After navigating back to homepage: no visual glitches, no stuck elements, no performance degradation
- Memory tab in DevTools: no runaway memory growth after repeated navigation
  </verify>
  <done>ScrollTrigger cleanup runs on every route change (kill all + refresh). Development logging confirms trigger count stays at baseline. Double-layer cleanup (useGSAP per-component + route-level killAll) prevents memory leaks.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify smooth scroll, accessibility, and cleanup</name>
  <files>none — verification only</files>
  <action>
Human verifies the complete animation foundation: GSAP + Lenis smooth scroll with accessibility support and ScrollTrigger cleanup.

Steps to verify:
1. Start dev server: `npm run dev`
2. Open http://localhost:3000 in browser

**Smooth scroll feel:**
3. Scroll with mouse wheel — should feel noticeably fluid, with momentum that fades out (like kota.co.uk)
4. Scroll with keyboard arrows, Space bar, Page Down — should scroll smoothly through Lenis
5. Navigate to a different page via nav links — page should instantly scroll to top (no gradual scroll animation during route change)
6. Click browser back button — previous page loads correctly

**Scrollbar hidden:**
7. Look at the right edge of the viewport — no scrollbar should be visible

**Accessibility:**
8. Open Chrome DevTools > Rendering panel > check "Emulate prefers-reduced-motion: reduce"
9. Scroll with mouse wheel — should now feel like NATIVE scroll (instant, no momentum)
10. Uncheck the emulation — smooth scroll should return immediately

**Existing functionality:**
11. Toggle dark/light theme — should still work
12. Scroll down past 500px — ScrollToTop button should appear and work when clicked
13. ChatWidget should remain functional

**No errors:**
14. Check browser console — no red errors related to GSAP, Lenis, hydration, or React
  </action>
  <verify>User runs through the 14-step verification above and reports "approved" or describes issues.</verify>
  <done>User confirms: smooth scroll feels fluid, keyboard scrolling works through Lenis, reduced motion disables smooth scroll, scrollbar is hidden, all existing functionality intact, no console errors.</done>
</task>

</tasks>

<verification>
1. `npm run build` — zero errors
2. `npm run dev` — smooth scroll working on homepage
3. Mouse wheel scroll — fluid, momentum-based (not native)
4. Keyboard scroll — goes through Lenis
5. Route change — instant scroll to top
6. Browser back — works correctly
7. Scrollbar — hidden
8. Reduced motion ON — native scroll, no animation
9. Reduced motion OFF — smooth scroll returns
10. Theme toggle — still works
11. ScrollToTop button — still appears and functions
12. ChatWidget — still functional
13. Console — no GSAP/Lenis/hydration errors
14. Navigate 5+ pages rapidly — no performance degradation or stuck elements
</verification>

<success_criteria>
- useReducedMotion hook reactively tracks OS/browser preference
- Lenis stops when reduced motion is active, starts when inactive
- ScrollTrigger cleanup runs on every route change
- Dev console debug logging confirms trigger count at 0 between pages
- All 4 phase requirements satisfied: ANIM-01 (centralized GSAP), ANIM-02 (Lenis + ticker sync), ANIM-05 (reduced motion), ANIM-06 (ScrollTrigger cleanup)
- Human verification confirms scroll feel matches expectations
</success_criteria>

<output>
After completion, create `.planning/phases/01-animation-foundation/01-02-SUMMARY.md`
</output>
